BROKER SCHEMA osler.mb

DECLARE getDefaultRoutingRulesURL EXTERNAL CHARACTER 'http://137.122.88.14:8080/osler-mb/event/getDefaultRoutingRules';

DECLARE ruleCache SHARED ROW;
DECLARE ruleRefreshAttempts SHARED INTEGER 0; -- Can be used to prevent endless refresh loops

CREATE COMPUTE MODULE ProcessEvent_ApplyRoutingRules
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		--Basic flow is:
		--1. Check if routing rules are cached in memory
		--	1.1 If not, initiate subflow to go get them
		--2. Prepare routing information based on routing rules and input message
		--3. Create a logEvent message and send it to the log queue
		--4. Propagate messages to destinations with routing parameters set
	
		IF CARDINALITY(ruleCache.oslerRoutingRules[]) = 0 THEN
			-- If the routing rules in shared memory is null, then go into the refresh routing rules sub-flow
			IF ruleRefreshAttempts > 0 THEN
				THROW USER EXCEPTION VALUES ('Attempted to get routing-rules twice in a row. Failed...');
			END IF;
			SET ruleRefreshAttempts = ruleRefreshAttempts + 1; 
		  	CALL CopyMessageHeaders(); 
		  	CALL CopyEntireMessage();
			RETURN TRUE;
		END IF;
		
		
		-- LOG EVENT VALUES ('Rules are cached', CARDINALITY(ruleCache.oslerRoutingRules[]), ruleCache.oslerRoutingRules, FIELDVALUE(ruleCache.oslerRoutingRules.events.event[1]));
		
		-- Prepare some of the variables needed from the message and from the routing rules		
		DECLARE eventName CHARACTER FIELDNAME(InputRoot.XMLNS.*[<]);
		DECLARE sourceSuffix CHARACTER FIELDVALUE(InputRoot.XMLNS.*[<].(XML.Attribute)sourceSuffix);
		DECLARE remoteHost CHARACTER FIELDVALUE(InputRoot.XMLNS.*[<].(XML.Attribute)remoteHost);
		DECLARE source CHARACTER 'UNKNOWN';
		DECLARE inputMethod CHARACTER 'NULL';		
		DECLARE inputMethodAttribute CHARACTER FIELDVALUE(InputRoot.XMLNS.*[<].(XML.Attribute)inputMethod);
		
		-- If an input method was added to the event, use it for logging
		IF inputMethodAttribute IS NOT NULL THEN
			SET inputMethod = inputMethodAttribute;
		END IF;
		
		-- Loop through the event sources and find one that matches the input remote host
		IF remoteHost IS NOT NULL THEN
			FOR s AS ruleCache.oslerRoutingRules.sources.source[] DO
				IF CONTAINS(LOWER(remoteHost), LOWER(s.matchingString)) THEN
					SET source = s.name;
				END IF; 
			END FOR;
		END IF;
		IF sourceSuffix IS NOT NULL THEN
			SET source = source || '-' || sourceSuffix;
		END IF;
		
		-- Create a message to send to the logger service (the console)
		CALL CopyMessageHeaders();
		SET OutputRoot.XMLNS.logEvent.event = eventName;
		SET OutputRoot.XMLNS.logEvent.source = source;
		SET OutputRoot.XMLNS.logEvent.inputMethod = inputMethod;
		PROPAGATE TO LABEL 'LOG';
		
		DECLARE numSent INTEGER 0;		
		-- Loop through each destination 
		-- WHILE i <= CARDINALITY(ruleCache.oslerRoutingRules.destinations.destination[]) DO
		FOR d AS ruleCache.oslerRoutingRules.destinations.destination[] DO
			-- Only process this destination if it is not disabled
			--IF NOT (UPPER(FIELDVALUE(d.(XML.Attribute)disabled)) = 'TRUE') THEN 	
				-- Test to see if this destination routes to this event (assume not at first)
			  	DECLARE hasEvent BOOLEAN FALSE;
			  	FOR e AS d.receives.event[] DO
			  		-- If hasEvent hasn't been set yet (no break in ESQL) and the event name matches the
			  		-- incoming event name, set to true
			  		IF NOT hasEvent AND FIELDVALUE(e) = eventName THEN
			  			SET hasEvent = TRUE;
			  		END IF; 
			  	END FOR;
			  	
			  	-- If the destination routes to this event, package up the message and propagate it accordingly
			  	IF hasEvent THEN
			  		-- Copy the entire message to the output
				  	CALL CopyMessageHeaders(); 
					CALL CopyEntireMessage();
					-- Remove all the intermediary attributes used thus far
					SET OutputRoot.XMLNS.*[<].(XML.Attribute)remoteHost = NULL;
					SET OutputRoot.XMLNS.*[<].(XML.Attribute)sourceSuffix = NULL;
					SET OutputRoot.XMLNS.*[<].(XML.Attribute)inputMethod = NULL;
					-- Set the destination parameters of the message (label is not strictly necessary since we are propagating directly to label, but it doesn't hurt)
				  	SET OutputLocalEnvironment.Destination.RouterList.DestinationData."label" = d.accessMethod;
				  	SET OutputLocalEnvironment.Destination.HTTP.RequestURL = d.url;
				  	-- Propagate to appropriate label
				  	PROPAGATE TO LABEL d.accessMethod; 
				  	-- Increment the number of messages sent (for possible tracing purposes)
				  	SET numSent = numSent + 1; 
			  	END IF;
			--END IF; -- If not disabled
		END FOR; 		  
		  
		RETURN FALSE; -- Do not propagate normally
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;

END MODULE;

CREATE COMPUTE MODULE RefreshRoutingRules_SetURL
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputLocalEnvironment.Destination.HTTP.RequestURL = getDefaultRoutingRulesURL;
		RETURN TRUE;
	END;
END MODULE;

CREATE COMPUTE MODULE ProcessEvent_ReplyWithRules
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		IF CARDINALITY(ruleCache.oslerRoutingRules[]) = 0 THEN
			-- No cached rules, so proceed to refresh them
			CALL CopyMessageHeaders(); 
		  	CALL CopyEntireMessage();			
			PROPAGATE TO TERMINAL 'out1' FINALIZE DEFAULT;
			RETURN FALSE;
		ELSE 
			SET OutputRoot.XMLNS = ruleCache;
			RETURN TRUE;
		END IF;		
	END;
	
	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;

-- Swaps out the event and continues
CREATE COMPUTE MODULE ProcessEvent_SwapMessage
		
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		-- Swap the input to a safe location in the local environment variables section
		--SET Environment.Variables.EventBody = InputRoot.XMLNS.*[<];
		CREATE LASTCHILD OF Environment DOMAIN 'XMLNS' NAME 'EventBody';
		SET Environment.EventBody = InputRoot.XMLNS;
		RETURN TRUE;
	END;

END MODULE;

-- Sets the routing rules into the local mem cache and then swaps the event back into the root
CREATE COMPUTE MODULE ProcessEvent_RefreshCache
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		-- Set the routing rules data into the shared mem cache
		SET ruleCache.oslerRoutingRules = InputRoot.XMLNS.*[<];		
		-- Swap the event back into the message body
		IF CARDINALITY(Environment.EventBody[]) > 0 THEN
			-- If possible, bring back the event into the output and clear the environment		
			SET ruleRefreshAttempts = 0;
			SET OutputRoot.XMLNS = Environment.EventBody;
			SET Environment.EventBody = InputRoot.XMLNS; 
		END IF;		
		RETURN TRUE;
	END;
	
	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;
END MODULE;


BROKER SCHEMA osler.mb

DECLARE getDefaultRoutingRulesURL EXTERNAL CHARACTER 'http://localhost/osler-mb/event/getDefaultRoutingRules';

DECLARE ruleCache SHARED ROW;
DECLARE ruleRefreshAttempts SHARED INTEGER 0; -- Can be used to prevent endless refresh loops

CREATE COMPUTE MODULE ProcessEvent_ApplyRoutingRules
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		--Basic flow is:
		--1. Check if routing rules are cached in memory
		--	1.1 If not, initiate subflow to go get them
		--2. Prepare routing information based on routing rules and input message 
		--3. If appropriate, route a message to the outbound queue (JMS)
		--4. Propagate messages to point-to-point destinations (HTTP or SOAP)
		--5. Create a logEvent message and send it to the log queue
	
		IF CARDINALITY(ruleCache.oslerRoutingRules[]) = 0 THEN
			-- If the routing rules in shared memory is null, then go into the refresh routing rules sub-flow
			IF ruleRefreshAttempts > 0 THEN
				THROW USER EXCEPTION VALUES ('Attempted to get routing-rules twice in a row. Failed...');
			END IF;
			SET ruleRefreshAttempts = ruleRefreshAttempts + 1; 
		  	SET OutputRoot = InputRoot;
			PROPAGATE TO TERMINAL 'out1' FINALIZE DEFAULT; -- Propagate to secondary terminal
			RETURN FALSE;
		END IF;
		
		-- LOG EVENT VALUES ('Rules are cached', CARDINALITY(ruleCache.oslerRoutingRules[]), ruleCache.oslerRoutingRules, FIELDVALUE(ruleCache.oslerRoutingRules.events.event[1]));
		
		-- Prepare some of the variables needed from the message and from the routing rules		
		DECLARE eventName CHARACTER FIELDNAME(InputRoot.XMLNSC.*[<]);
		DECLARE sourceSuffix CHARACTER FIELDVALUE(InputRoot.XMLNSC.*[<].(XMLNSC.Attribute)sourceSuffix);
		DECLARE remoteHost CHARACTER FIELDVALUE(InputRoot.XMLNSC.*[<].(XMLNSC.Attribute)remoteHost);
		DECLARE source CHARACTER 'UNKNOWN';
		DECLARE inputMethod CHARACTER 'NULL';		
		DECLARE inputMethodAttribute CHARACTER FIELDVALUE(InputRoot.XMLNSC.*[<].(XMLNSC.Attribute)inputMethod);
		
		-- If an input method was added to the event, use it for logging
		IF inputMethodAttribute IS NOT NULL THEN
			SET inputMethod = inputMethodAttribute;
		END IF;
		
		-- Loop through the event sources and find one that matches the input remote host
		IF remoteHost IS NOT NULL THEN
			FOR s AS ruleCache.oslerRoutingRules.sources.source[] DO
				IF CONTAINS(LOWER(remoteHost), LOWER(s.matchingString)) THEN
					SET source = s.name;
				END IF; 
			END FOR;
		END IF;
		IF sourceSuffix IS NOT NULL THEN
			SET source = source || '-' || sourceSuffix;
		END IF;
			
		DECLARE numSentP2P INTEGER 0;
		DECLARE numSentPubSub INTEGER 0;
		
		-- Check if any destination receives via JMS. If so, propagate one message to JMS
		DECLARE hasJms BOOLEAN FALSE;
		FOR d AS ruleCache.oslerRoutingRules.destinations.destination[] DO
			IF NOT hasJms AND d.(XMLNSC.Attribute)disabled IS NULL AND d.accessMethod = 'JMS' THEN
				SET hasJms = TRUE;
			END IF;
		END FOR;
		IF hasJms THEN
			CALL CopyEntireMessage();
			PROPAGATE TO LABEL 'JMS'; 	
			SET numSentPubSub = numSentPubSub + 1;					
		END IF; -- If hasJms
		
		-- Loop through each destination that requires point-to-point (HTTP and SOAP)
		FOR d AS ruleCache.oslerRoutingRules.destinations.destination[] DO
			 -- If the destination uses HTTP, SOAP or TWS, and it's not disabled, then process it
			IF (d.accessMethod = 'HTTP' OR d.accessMethod = 'SOAP' OR d.accessMethod = 'TWS') AND d.(XMLNSC.Attribute)disabled IS NULL THEN
				-- Set some environment variables that can be used later for logging
			  	SET Environment.Variables.EventName = eventName;
			  	SET Environment.Variables.DestinationName = d.name;
			  	SET Environment.Variables.AccessMethod = d.accessMethod;
				
				-- Test to see if this destination routes to this event (assume not at first)
			  	DECLARE hasEvent BOOLEAN FALSE;
			  	FOR e AS d.receives.event[] DO
			  		-- If event name matches the incoming event name, set to true
			  		IF NOT hasEvent AND FIELDVALUE(e) = eventName THEN
			  			SET hasEvent = TRUE;
			  		END IF; 
			  	END FOR;
			  	
			  	-- If the destination routes to this event, package up the message and propagate it accordingly
			  	IF hasEvent THEN			  		
			  		-- Copy the entire message to the output				  
					CALL CopyEntireMessage();										
					-- Set the destination parameters of the message (label is not strictly necessary since we are propagating directly to label, but it doesn't hurt)
				  	SET OutputLocalEnvironment.Destination.RouterList.DestinationData."label" = d.accessMethod;
				  	SET OutputLocalEnvironment.Destination.HTTP.RequestURL = d.url;
				  	-- Propagate to appropriate label
				  	PROPAGATE TO LABEL d.accessMethod FINALIZE NONE;
				  	-- Increment the counter
				  	SET numSentP2P = numSentP2P + 1; 
			  	END IF;
			  	
			END IF; -- If the destination is HTTP or SOAP, and not disabled
			
		END FOR; 		  
				
		-- Create a message to send to the logger service (the console)
		CALL CopyMessageHeaders();
		SET OutputRoot.XMLNSC.logEvent.event = eventName;
		SET OutputRoot.XMLNSC.logEvent.source = source;
		SET OutputRoot.XMLNSC.logEvent.inputMethod = inputMethod;
		SET OutputRoot.XMLNSC.logEvent.numSentPubSub = numSentPubSub;
		SET OutputRoot.XMLNSC.logEvent.numSentP2P = numSentP2P;		
		RETURN TRUE; -- Propagate this final message to the default (out) terminal
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
		-- On the outbound message, remove intermediary attributes
		SET OutputRoot.XMLNSC.*[<].(XMLNSC.Attribute)remoteHost = NULL;
		SET OutputRoot.XMLNSC.*[<].(XMLNSC.Attribute)sourceSuffix = NULL;
		SET OutputRoot.XMLNSC.*[<].(XMLNSC.Attribute)inputMethod = NULL;		
	END;

END MODULE;

CREATE COMPUTE MODULE RefreshRoutingRules_SetURL
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		SET OutputLocalEnvironment.Destination.HTTP.RequestURL = getDefaultRoutingRulesURL;
		RETURN TRUE;
	END;
END MODULE;

CREATE COMPUTE MODULE ProcessEvent_ReplyWithRules
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		IF CARDINALITY(ruleCache.oslerRoutingRules[]) = 0 THEN
			-- No cached rules, so proceed to refresh them
			CALL CopyMessageHeaders(); 
		  	CALL CopyEntireMessage();			
			PROPAGATE TO TERMINAL 'out1' FINALIZE DEFAULT;
			RETURN FALSE;
		ELSE 
			SET OutputRoot.XMLNSC = ruleCache;
			RETURN TRUE;
		END IF;		
	END;
	
	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
END MODULE;

-- Swaps out the event and continues
CREATE COMPUTE MODULE ProcessEvent_SwapMessage
		
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		-- Swap the input to a safe location in the local environment variables section
		--SET Environment.Variables.EventBody = InputRoot.XMLNSC.*[<];
		CREATE LASTCHILD OF Environment.Variables DOMAIN 'XMLNSC' NAME 'EventBody';
		SET Environment.Variables.EventBody = InputRoot.XMLNSC;
		RETURN TRUE;
	END;

END MODULE;

-- Sets the routing rules into the local mem cache and then swaps the event back into the root
CREATE COMPUTE MODULE ProcessEvent_RefreshCache
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		-- Set the routing rules data into the shared mem cache
		SET ruleCache.oslerRoutingRules = InputRoot.XMLNSC.*[<];		
		-- Swap the event back into the message body
		IF CARDINALITY(Environment.Variables.EventBody[]) > 0 THEN
			-- If possible, bring back the event into the output and clear the environment		
			SET ruleRefreshAttempts = 0;
			SET OutputRoot.XMLNSC = Environment.Variables.EventBody;
			SET Environment.Variables.EventBody = NULL; 
		END IF;		
		RETURN TRUE;
	END;
	
	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;
END MODULE;



CREATE COMPUTE MODULE ProcessEvent_PrepareLogResponse
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN		
		SET OutputRoot.XMLNSC.logResponse.event = Environment.Variables.EventName;
		SET OutputRoot.XMLNSC.logResponse.destinationName = Environment.Variables.DestinationName;
		SET OutputRoot.XMLNSC.logResponse.accessMethod = Environment.Variables.AccessMethod;
		SET OutputRoot.XMLNSC.logResponse.responseStatusCode = InputRoot.HTTPResponseHeader."X-Original-HTTP-Status-Code";
		RETURN TRUE;
	END;
END MODULE;
